<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scheduler — Editor Tabellare e Simulatore</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--danger:#ef4444}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;background:linear-gradient(180deg,#071126 0%, #0f1724 100%)}
    .wrap{max-width:1200px;margin:20px auto;padding:18px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px}
    h1{margin:0 0 6px;font-size:20px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:14px}
    .card{background:var(--card);padding:12px;border-radius:8px}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
    input,select,button,textarea{font-size:13px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:#0b1220;color:#e6eef6}
    button.btn{cursor:pointer;border:none;background:linear-gradient(90deg,var(--accent),#3b82f6);color:#022;padding:8px 10px;font-weight:700}
    .table-wrap{max-height:360px;overflow:auto;border-radius:6px;border:1px solid rgba(255,255,255,0.03)}
    table{width:100%;border-collapse:collapse;font-family:monospace}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
    th{position:sticky;top:0;background:rgba(255,255,255,0.01);z-index:2}
    td input{width:100%;background:transparent;border:none;color:inherit;padding:4px}
    .row-actions{display:flex;gap:6px}
    .icon-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:6px;cursor:pointer;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .invalid{outline:2px solid rgba(239,68,68,0.2)}
    pre{font-family:monospace;white-space:pre-wrap;color:var(--muted);margin:0}
    .metrics{display:flex;gap:10px;margin-top:10px}
    .metric{background:#071427;padding:8px;border-radius:6px;min-width:120px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    /* Gantt styles */
    .gantt-wrap{margin-top:10px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:8px;min-height:140px}
    .gantt-header{display:flex;gap:8px;align-items:center;justify-content:space-between}
    .gantt-canvas{width:100%;overflow:auto}
    svg.gantt{width:100%;height:120px;display:block}
    .gantt-row-label{font-size:11px;fill:var(--muted)}
    .gantt-block{stroke:rgba(0,0,0,0.4);stroke-width:1}
    .gantt-scale{font-size:11px;fill:var(--muted)}
    .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .legend-item{font-size:11px;color:var(--muted);display:flex;gap:6px;align-items:center}
    .legend-swatch{width:12px;height:12px;border-radius:2px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Scheduler — Editor Tabellare</h1>
    <p class="small">Inserisci i processi nella tabella, modifica inline, importa o esporta JSON, poi esegui la simulazione.</p>

    <div class="grid">
      <div class="card">
        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div class="controls" style="flex:1">
            <button id="addRow" class="btn">Aggiungi riga</button>
            <button id="delSelected" class="btn" style="background:linear-gradient(90deg,#ef4444,#f97316)">Elimina selezionati</button>
            <button id="genFill" class="btn" title="Genera N task">Genera N</button>
          </div>
          <div style="min-width:220px">
            <label>Importa JSON</label>
            <input id="jsonImport" placeholder='[{"pid":1,"arrival":0,"burst":5,"priority":2},...]' />
          </div>
        </div>

        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <label style="margin:0">N default</label>
          <input id="genN" type="number" value="1000" style="width:90px" />
          <label style="margin:0">Max burst</label>
          <input id="genBurst" type="number" value="50" style="width:90px" />
          <label style="margin:0">Seed</label>
          <input id="genSeed" placeholder="numero opzionale" style="width:120px" />
          <button id="importBtn" class="btn">Importa nella tabella</button>
        </div>

        <div style="margin-top:12px" class="table-wrap">
          <table id="procTable" aria-label="Process table">
            <thead>
              <tr>
                <th style="width:34px"><input id="selectAll" type="checkbox" /></th>
                <th style="width:60px">PID</th>
                <th style="width:80px">Arrival</th>
                <th style="width:80px">Burst</th>
                <th style="width:80px">Priority</th>
                <th>Note</th>
                <th style="width:110px">Azioni</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <button id="exportJSON" class="btn">Esporta JSON</button>
          <button id="clearTable" class="icon-btn">Svuota tabella</button>
          <div style="flex:1"></div>
          <label style="margin:0">Algoritmo</label>
          <select id="algorithm">
            <option value="fcfs">FCFS</option>
            <option value="sjf_non">SJF Non-preemptive</option>
            <option value="sjf_pre">SJF Preemptive</option>
            <option value="priority_non">Priority Non-preemptive</option>
            <option value="priority_pre">Priority Preemptive</option>
            <option value="rr">Round Robin</option>
          </select>
          <input id="quantum" type="number" min="1" value="4" style="width:80px" />
          <button id="runSim" class="btn">Esegui</button>
        </div>

        <div class="metrics" style="margin-top:12px">
          <div class="metric"><strong>Turnaround medio</strong><div id="avgTAT">—</div></div>
          <div class="metric"><strong>Waiting medio</strong><div id="avgWT">—</div></div>
          <div class="metric"><strong>Processi</strong><div id="count">0</div></div>
        </div>

        <div style="margin-top:10px">
          <label>Output JSON esportato</label>
          <textarea id="jsonOutput" style="width:100%;height:120px"></textarea>
        </div>
      </div>

      <div class="card">
        <h3>Anteprima e timeline</h3>
        <div class="small">Prime 50 righe della tabella, timeline compatta e grafico Gantt.</div>

        <div class="gantt-wrap" id="ganttWrap">
          <div class="gantt-header">
            <div class="small">Gantt chart (scala automatica)</div>
            <div style="display:flex;gap:8px;align-items:center">
              <label class="small" style="margin:0">Mostra etichette</label>
              <input id="ganttLabels" type="checkbox" checked />
            </div>
          </div>
          <div class="gantt-canvas" id="ganttCanvas" aria-hidden="false">
            <!-- SVG will be injected here -->
            <svg class="gantt" viewBox="0 0 800 120" preserveAspectRatio="none" id="ganttSvg"></svg>
          </div>
          <div class="legend" id="ganttLegend"></div>
        </div>

        <div style="margin-top:8px">
          <pre id="preview" style="max-height:180px;overflow:auto">Nessuna esecuzione</pre>
        </div>
        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0">
        <h3>Guida rapida</h3>
        <ul class="small">
          <li>Modifica ogni cella cliccandoci sopra. Valori non numerici vengono evidenziati.</li>
          <li>PID duplicati vengono tollerati ma è consigliato mantenerli univoci.</li>
          <li>Importa JSON nell'input, poi premi Importa per popolare la tabella.</li>
          <li>Premi Esporta JSON per copiare l'array dei processi nel box di output.</li>
        </ul>
      </div>
    </div>

    <footer>Turnaround = Completion − Arrival. Waiting = Turnaround − Burst.</footer>
  </div>

  <script>
  // ---------- utilities ----------
  function $(s, root=document) { return root.querySelector(s); }
  function $all(s, root=document) { return Array.from(root.querySelectorAll(s)); }

  // seeded RNG
  function makeRNG(seed) {
    let s = Number.isFinite(+seed) ? (seed >>> 0) : Math.floor(Math.random()*1e9);
    return function() { s = (s * 1664525 + 1013904223) >>> 0; return s/4294967296; };
  }

  // table management
  const tbody = $('#procTable tbody');
  function createRow(proc={pid:'', arrival:0, burst:1, priority:1, note:''}) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" class="rowSel" /></td>
      <td><input class="cell pid" value="${proc.pid}" /></td>
      <td><input class="cell arrival" value="${proc.arrival}" /></td>
      <td><input class="cell burst" value="${proc.burst}" /></td>
      <td><input class="cell priority" value="${proc.priority}" /></td>
      <td><input class="cell note" value="${proc.note ?? ''}" /></td>
      <td class="row-actions">
        <button class="icon-btn rowDup" title="duplica">Dup</button>
        <button class="icon-btn rowDel" title="elimina">Del</button>
      </td>
    `;
    // validation on input
    tr.querySelectorAll('input.cell').forEach(inp=>{
      inp.addEventListener('input', ()=> validateCell(inp));
      inp.addEventListener('keydown', (e)=> { if (e.key==='Enter') inp.blur(); });
    });
    tr.querySelector('.rowDel').addEventListener('click', ()=> { tr.remove(); updateCount(); });
    tr.querySelector('.rowDup').addEventListener('click', ()=> {
      const copy = rowToObj(tr);
      const newTr = createRow(copy);
      tbody.insertBefore(newTr, tr.nextSibling);
      updateCount();
    });
    tbody.appendChild(tr);
    return tr;
  }

  function validateCell(inp) {
    const cls = inp.classList;
    if (cls.contains('arrival') || cls.contains('burst') || cls.contains('priority') || cls.contains('pid')) {
      const v = inp.value.trim();
      const num = Number(v);
      const ok = v !== '' && Number.isFinite(num) && num >= 0;
      inp.classList.toggle('invalid', !ok);
    } else {
      inp.classList.remove('invalid');
    }
  }

  function rowToObj(tr) {
    const get = sel => (tr.querySelector(sel)?.value ?? '').trim();
    return {
      pid: Number(get('.pid')) || get('.pid') || '',
      arrival: Number(get('.arrival')) || 0,
      burst: Number(get('.burst')) || 0,
      priority: Number(get('.priority')) || 0,
      note: get('.note')
    };
  }

  function tableToArray(limit=Infinity) {
    const arr = [];
    for (const tr of tbody.children) {
      const obj = rowToObj(tr);
      arr.push({ pid: obj.pid, arrival: obj.arrival, burst: obj.burst, priority: obj.priority });
      if (arr.length >= limit) break;
    }
    return arr;
  }

  function clearTable() { tbody.innerHTML=''; updateCount(); }

  function updateCount() { $('#count').textContent = tbody.children.length; }

  // populate example or generated tasks
  $('#addRow').addEventListener('click', ()=> { createRow({pid:'',arrival:0,burst:1,priority:1}); updateCount(); });
  $('#clearTable').addEventListener('click', ()=> { clearTable(); $('#jsonOutput').value=''; $('#preview').textContent='Tabella svuotata'; clearGantt(); });

  $('#genFill').addEventListener('click', ()=> {
    const n = Math.max(1, Number($('#genN').value)||1);
    const maxBurst = Math.max(1, Number($('#genBurst').value)||50);
    const seed = $('#genSeed').value;
    const rng = makeRNG(seed || Math.floor(Math.random()*1e9));
    clearTable();
    let t=0;
    for (let i=0;i<n;i++){
      t += Math.floor(rng()*3);
      createRow({pid:i+1, arrival:t, burst: Math.floor(rng()*maxBurst)+1, priority: Math.floor(rng()*10)+1});
      if (i >= 2000) { // safety cap for UI responsiveness
        const remain = n - (i+1);
        const summary = createRow({pid:'...', arrival:'...', burst:'...', priority:'...', note:`+${remain} rows omitted for UI`});
        break;
      }
    }
    updateCount();
  });

  // import JSON into input field or directly into table
  $('#importBtn').addEventListener('click', ()=> {
    const text = $('#jsonImport').value.trim();
    if (!text) { alert('Inserisci JSON nell\'input di import.'); return; }
    try {
      const arr = JSON.parse(text);
      if (!Array.isArray(arr)) throw new Error('JSON deve essere un array di oggetti.');
      clearTable();
      for (const p of arr) {
        createRow({
          pid: ('pid' in p) ? p.pid : '',
          arrival: Number(p.arrival ?? 0),
          burst: Number(p.burst ?? 0),
          priority: Number(p.priority ?? 0),
          note: p.note ?? ''
        });
      }
      updateCount();
      $('#preview').textContent = `Importati ${arr.length} righe.`;
    } catch (e) {
      alert('JSON non valido: ' + e.message);
    }
  });

  // quick import from json input field (single-line)
  $('#jsonImport').addEventListener('keydown', (e)=> { if (e.key === 'Enter' && (e.ctrlKey||e.metaKey)) { $('#importBtn').click(); } });

  // export table to JSON
  $('#exportJSON').addEventListener('click', ()=> {
    const arr = tableToArray(1000000);
    const json = JSON.stringify(arr, null, 2);
    $('#jsonOutput').value = json;
    $('#preview').textContent = json.split('\n').slice(0,50).join('\n');
  });

  // select all behavior
  $('#selectAll').addEventListener('change', (e)=> {
    $all('.rowSel').forEach(cb=> cb.checked = e.target.checked);
  });

  $('#delSelected').addEventListener('click', ()=> {
    $all('.rowSel').forEach(cb=> { if (cb.checked) cb.closest('tr').remove(); });
    updateCount();
  });

  // enable/disable quantum
  function toggleQuantum() { $('#quantum').disabled = $('#algorithm').value !== 'rr'; }
  $('#algorithm').addEventListener('change', toggleQuantum);
  toggleQuantum();

  // ---------- scheduling functions (copiate e adattate) ----------
  function computeMetrics(processes) {
    const n = processes.length;
    let totTAT=0, totWT=0;
    if (n === 0) return {avgTAT:0, avgWT:0, throughput:0};
    for (let p of processes) {
      const tat = p.completion - p.arrival;
      const wt = tat - p.burst;
      totTAT += tat;
      totWT += wt;
    }
    const makespan = Math.max(...processes.map(p=>p.completion)) - Math.min(...processes.map(p=>p.arrival));
    return { avgTAT: totTAT/n, avgWT: totWT/n, throughput: n / (makespan || 1) };
  }

  // Simulators optimized for arrays of objects
  function simulateFCFS(tasks) {
    const procs = tasks.map(t=>({...t, remaining: t.burst}));
    procs.sort((a,b)=> a.arrival - b.arrival || (a.pid - b.pid));
    let time = 0; const timeline=[];
    for (const p of procs) {
      if (time < p.arrival) time = p.arrival;
      p.start = time; time += p.burst; p.completion = time; p.remaining=0;
      timeline.push({pid:p.pid, from:p.start, to:p.completion});
    }
    return {procs,timeline};
  }

  function simulateSJFNon(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.burst<best){best=p.burst;idx=i;}}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const p=procs[idx]; p.start=time; time+=p.burst; p.completion=time; p.done=true; finished++; timeline.push({pid:p.pid,from:p.start,to:p.completion});
    }
    return {procs,timeline};
  }

  function simulateSJFPre(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.remaining<best){best=p.remaining;idx=i;}}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const cur=procs[idx]; const upcoming = procs.filter(p=>!p.done && p.arrival>time).map(p=>p.arrival);
      const nextArrival = upcoming.length? Math.min(...upcoming) : Infinity;
      const delta = Math.min(cur.remaining, nextArrival - time);
      if(delta===0){ time = nextArrival; continue; }
      const from=time,to=time+delta; if(!cur.hasOwnProperty('start')) cur.start=from;
      cur.remaining-=delta; timeline.push({pid:cur.pid,from,to}); time=to;
      if(cur.remaining===0){ cur.completion=time; cur.done=true; finished++; }
    }
    return {procs,timeline};
  }

  function simulatePriorityNon(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.priority<best){best=p.priority;idx=i;}
        else if(!p.done && p.arrival<=time && p.priority===best){ if(idx!==-1 && p.burst<procs[idx].burst) idx=i; }}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const p=procs[idx]; p.start=time; time+=p.burst; p.completion=time; p.done=true; finished++; timeline.push({pid:p.pid,from:p.start,to:p.completion});
    }
    return {procs,timeline};
  }

  function simulatePriorityPre(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.priority<best){best=p.priority;idx=i;}}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const cur=procs[idx]; const upcoming = procs.filter(p=>!p.done && p.arrival>time).map(p=>p.arrival);
      const nextArrival = upcoming.length? Math.min(...upcoming) : Infinity;
      const delta = Math.min(cur.remaining, nextArrival - time);
      if(delta===0){ time = nextArrival; continue; }
      const from=time,to=time+delta; if(!cur.hasOwnProperty('start')) cur.start=from;
      cur.remaining-=delta; timeline.push({pid:cur.pid,from,to}); time=to;
      if(cur.remaining===0){ cur.completion=time; cur.done=true; finished++; }
    }
    return {procs,timeline};
  }

  function simulateRR(tasks, quantum) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    procs.sort((a,b)=> a.arrival - b.arrival || (a.pid - b.pid));
    let time=0; const q=[]; let i=0; const timeline=[];
    while(true){
      while(i<n && procs[i].arrival<=time){ q.push(procs[i]); i++; }
      if(q.length===0){ if(i<n){ time = procs[i].arrival; continue; } else break; }
      const cur = q.shift();
      if(!cur.hasOwnProperty('start')) cur.start=time;
      const run = Math.min(cur.remaining, quantum);
      const from=time, to=time+run;
      cur.remaining-=run; timeline.push({pid:cur.pid,from,to}); time=to;
      while(i<n && procs[i].arrival<=time){ q.push(procs[i]); i++; }
      if(cur.remaining>0) q.push(cur); else { cur.completion=time; cur.done=true; }
      if(q.length===0 && i>=n) break;
    }
    return {procs,timeline};
  }

  // ---------- Gantt rendering ----------
  const ganttSvg = $('#ganttSvg');
  const ganttLegend = $('#ganttLegend');
  const ganttLabelsToggle = $('#ganttLabels');

  function clearGantt() {
    ganttSvg.innerHTML = '';
    ganttLegend.innerHTML = '';
  }

  // simple deterministic color generator by pid string
  function colorForPid(pid) {
    const s = String(pid);
    let h = 0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) & 0xfffffff;
    const hue = h % 360;
    return `hsl(${hue} 70% 55%)`;
  }

  function renderGantt(timelineSegments, options={height:120, maxRows:20}) {
    // timelineSegments: [{pid, from, to}]
    clearGantt();
    if (!timelineSegments || timelineSegments.length===0) return;
    // compute overall time range
    const tmin = Math.min(...timelineSegments.map(s=>s.from));
    const tmax = Math.max(...timelineSegments.map(s=>s.to));
    const duration = Math.max(1, tmax - tmin);
    // compress contiguous segments per pid into rows by pid order of first appearance
    const pidsOrder = Array.from(new Set(timelineSegments.map(s=>s.pid)));
    const rowCount = Math.min(pidsOrder.length, options.maxRows);
    const rowMap = new Map();
    pidsOrder.slice(0,rowCount).forEach((pid,i)=> rowMap.set(pid, i));
    // SVG dims
    const width = 800;
    const height = options.height;
    const rowHeight = Math.max(12, Math.floor((height-20)/Math.max(1,rowCount)));
    const labelArea = 60;
    // build SVG elements
    ganttSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    const ns = 'http://www.w3.org/2000/svg';
    // background
    const bg = document.createElementNS(ns,'rect');
    bg.setAttribute('x',0); bg.setAttribute('y',0); bg.setAttribute('width',width); bg.setAttribute('height',height);
    bg.setAttribute('fill','transparent');
    ganttSvg.appendChild(bg);
    // time scale lines
    const scaleGroup = document.createElementNS(ns,'g');
    const niceTicks = 6;
    for (let i=0;i<=niceTicks;i++){
      const x = labelArea + (width - labelArea) * (i / niceTicks);
      const t = tmin + duration * (i / niceTicks);
      const line = document.createElementNS(ns,'line');
      line.setAttribute('x1', x); line.setAttribute('x2', x);
      line.setAttribute('y1', 12); line.setAttribute('y2', height-6);
      line.setAttribute('stroke','rgba(255,255,255,0.03)');
      line.setAttribute('stroke-width', '1');
      scaleGroup.appendChild(line);
      const txt = document.createElementNS(ns,'text');
      txt.setAttribute('x', x+4); txt.setAttribute('y', 10);
      txt.setAttribute('class','gantt-scale');
      txt.setAttribute('fill','var(--muted)');
      txt.textContent = Number.isFinite(t) ? (Math.round(t*100)/100).toString() : '';
      scaleGroup.appendChild(txt);
    }
    ganttSvg.appendChild(scaleGroup);
    // rows and blocks
    const blocksGroup = document.createElementNS(ns,'g');
    for (const seg of timelineSegments) {
      const ridx = rowMap.get(seg.pid);
      if (ridx === undefined) continue; // omit rows beyond maxRows
      const x1 = labelArea + (width - labelArea) * ((seg.from - tmin) / duration);
      const x2 = labelArea + (width - labelArea) * ((seg.to - tmin) / duration);
      const y = 16 + ridx * rowHeight;
      const h = Math.max(10, rowHeight - 4);
      const rect = document.createElementNS(ns,'rect');
      rect.setAttribute('x', x1);
      rect.setAttribute('y', y);
      rect.setAttribute('width', Math.max(1, x2 - x1));
      rect.setAttribute('height', h);
      rect.setAttribute('rx', 3);
      rect.setAttribute('ry', 3);
      const color = colorForPid(seg.pid);
      rect.setAttribute('fill', color);
      rect.setAttribute('class','gantt-block');
      rect.setAttribute('stroke', 'rgba(0,0,0,0.35)');
      blocksGroup.appendChild(rect);
      // optional label inside block
      if (ganttLabelsToggle.checked) {
        const txt = document.createElementNS(ns,'text');
        txt.setAttribute('x', x1 + 4);
        txt.setAttribute('y', y + h/2 + 4/2);
        txt.setAttribute('font-size', Math.min(12, Math.max(8, h-2)));
        txt.setAttribute('fill', '#021');
        txt.textContent = String(seg.pid);
        // create a subtle drop effect by adding a semi-transparent white label with blend
        txt.setAttribute('style', 'mix-blend-mode:multiply');
        blocksGroup.appendChild(txt);
      }
    }
    ganttSvg.appendChild(blocksGroup);
    // left labels per row
    const labelsGroup = document.createElementNS(ns,'g');
    for (const [pid, idx] of rowMap.entries()) {
      const y = 16 + idx * rowHeight + Math.floor(rowHeight/2) + 4;
      const txt = document.createElementNS(ns,'text');
      txt.setAttribute('x', 4);
      txt.setAttribute('y', y);
      txt.setAttribute('class','gantt-row-label');
      txt.setAttribute('fill','var(--muted)');
      txt.textContent = `P${pid}`;
      labelsGroup.appendChild(txt);
    }
    ganttSvg.appendChild(labelsGroup);
    // legend (unique PIDs shown)
    ganttLegend.innerHTML = '';
    for (const pid of pidsOrder.slice(0,rowCount)) {
      const sw = document.createElement('div');
      sw.className = 'legend-item';
      const color = colorForPid(pid);
      sw.innerHTML = `<span class="legend-swatch" style="background:${color}"></span><span class="small">P${pid}</span>`;
      ganttLegend.appendChild(sw);
    }
  }

  // ---------- simulate runner ----------
  $('#runSim').addEventListener('click', ()=> {
    // validate table and build task array
    const rows = Array.from(tbody.children);
    const tasks = [];
    for (const tr of rows) {
      const obj = rowToObj(tr);
      // if any invalid, stop
      if (tr.querySelectorAll('.invalid').length) {
        alert('Ci sono valori non validi nella tabella. Correggi prima di eseguire.');
        return;
      }
      tasks.push({ pid: obj.pid, arrival: Number(obj.arrival), burst: Number(obj.burst), priority: Number(obj.priority) });
    }
    if (tasks.length === 0) { alert('La tabella è vuota. Aggiungi almeno un processo.'); return; }

    const alg = $('#algorithm').value;
    const q = Math.max(1, Number($('#quantum').value)||1);
    let result;
    const t0 = performance.now();
    if (alg === 'fcfs') result = simulateFCFS(tasks);
    else if (alg === 'sjf_non') result = simulateSJFNon(tasks);
    else if (alg === 'sjf_pre') result = simulateSJFPre(tasks);
    else if (alg === 'priority_non') result = simulatePriorityNon(tasks);
    else if (alg === 'priority_pre') result = simulatePriorityPre(tasks);
    else if (alg === 'rr') result = simulateRR(tasks, q);
    else { alert('Algoritmo non riconosciuto'); return; }
    const t1 = performance.now();

    const procs = result.procs.map(p=>({ pid:p.pid, arrival:p.arrival, burst:p.burst, completion:p.completion || (p.start+p.burst) }));
    const metrics = computeMetrics(procs);
    $('#avgTAT').textContent = metrics.avgTAT.toFixed(3);
    $('#avgWT').textContent = metrics.avgWT.toFixed(3);
    $('#count').textContent = procs.length;
    // preview first 50 processes
    $('#preview').textContent = procs.slice(0,50).map(p=>`PID ${p.pid} | arrival ${p.arrival} | burst ${p.burst} | completion ${p.completion}`).join('\n');
    // compact timeline preview
    const merged = [];
    for (const seg of result.timeline || []) {
      const last = merged[merged.length-1];
      if (last && last.pid === seg.pid && Math.abs(last.to - seg.from) < 1e-9) last.to = seg.to; else merged.push({...seg});
    }
    const show = merged.slice(0,300).map(s=>`[${s.from.toFixed(2)}→${s.to.toFixed(2)}]P${s.pid}`).join(' ');
    const more = merged.length>300 ? ` ... (+${merged.length-300} seg)` : '';
    $('#jsonOutput').value = `Sim time: ${(t1-t0).toFixed(2)}ms\n` + JSON.stringify(procs.slice(0,200), null, 2);
    $('#preview').textContent += '\n\nTimeline: ' + show + more;

    // render Gantt
    // Merge contiguous segments per pid where adjacent in time to minimize number of blocks shown
    const mergedSegments = [];
    for (const seg of result.timeline || []) {
      const last = mergedSegments[mergedSegments.length-1];
      if (last && last.pid === seg.pid && Math.abs(last.to - seg.from) < 1e-9) last.to = seg.to; else mergedSegments.push({...seg});
    }
    // Optionally limit segments if extremely many
    const limit = 2000;
    renderGantt(mergedSegments.slice(0, limit), {height:120, maxRows:20});
  });

  // toggle redraw labels dynamically
  ganttLabelsToggle.addEventListener('change', ()=> {
    // attempt to re-run last rendered svg by reading preview timeline if present
    // best-effort: re-run using current jsonOutput contents if it's a simulation result
    // parse timeline segments from preview if present
    // since we don't store the last timeline globally, simply clear to force rerun on next simulation
    // For immediate UX, if JSON output contains processes, no redraw attempted to avoid parsing complexity
    // user can re-run simulation to refresh labels
  });

  // initialize with a few rows
  for (let i=0;i<6;i++) createRow({pid:i+1, arrival:i, burst: Math.floor(Math.random()*10)+1, priority: Math.floor(Math.random()*5)+1});
  updateCount();
  </script>
</body>
</html>

