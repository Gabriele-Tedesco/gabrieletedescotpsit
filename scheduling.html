<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scheduler — Editor Tabellare e Simulatore</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--danger:#ef4444}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;background:linear-gradient(180deg,#071126 0%, #0f1724 100%)}
    .wrap{max-width:1200px;margin:20px auto;padding:18px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px}
    h1{margin:0 0 6px;font-size:20px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:14px}
    .card{background:var(--card);padding:12px;border-radius:8px}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
    input,select,button,textarea{font-size:13px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#e6eef6}
    button.btn{cursor:pointer;border:none;background:linear-gradient(90deg,var(--accent),#3b82f6);color:#022;padding:8px 10px;font-weight:700}
    .table-wrap{max-height:360px;overflow:auto;border-radius:6px;border:1px solid rgba(255,255,255,0.03)}
    table{width:100%;border-collapse:collapse;font-family:monospace}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
    th{position:sticky;top:0;background:rgba(255,255,255,0.01);z-index:2}
    td input{width:100%;background:transparent;border:none;color:inherit;padding:4px}
    .row-actions{display:flex;gap:6px}
    .icon-btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:6px;cursor:pointer;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}
    .invalid{outline:2px solid rgba(239,68,68,0.2)}
    pre{font-family:monospace;white-space:pre-wrap;color:var(--muted);margin:0}
    .metrics{display:flex;gap:10px;margin-top:10px}
    .metric{background:#071427;padding:8px;border-radius:6px;min-width:120px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    @media (max-width: 768px) {
  .grid {
    grid-template-columns: 1fr;
  }

  .controls {
    flex-direction: column;
    gap: 10px;
  }

  .table-wrap {
    overflow-x: auto;
  }

  table {
    font-size: 12px;
  }

  th, td {
    padding: 6px;
  }

  input, select, button, textarea {
    font-size: 14px;
    padding: 10px;
  }

  .metrics {
    flex-direction: column;
  }

  .metric {
    min-width: auto;
  }

  .row-actions {
    flex-direction: column;
    gap: 4px;
  }

  .icon-btn {
    padding: 6px 8px;
  }

  .wrap {
    padding: 12px;
  }
}

  </style>
</head>
<body>
  <div class="wrap">
    <h1>Scheduler — Editor Tabellare</h1>
    <p class="small">Inserisci i processi nella tabella, modifica inline, importa o esporta JSON, poi esegui la simulazione.</p>

    <div class="grid">
      <div class="card">
        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div class="controls" style="flex:1">
            <button id="addRow" class="btn">Aggiungi riga</button>
            <button id="delSelected" class="btn" style="background:linear-gradient(90deg,#ef4444,#f97316)">Elimina selezionati</button>
            <button id="genFill" class="btn" title="Genera N task">Genera N</button>
          </div>
          <div style="min-width:220px">
            <label>Importa JSON</label>
            <input id="jsonImport" placeholder='[{"pid":1,"arrival":0,"burst":5,"priority":2},...]' />
          </div>
        </div>

        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <label style="margin:0">N default</label>
          <input id="genN" type="number" value="1000" style="width:90px" />
          <label style="margin:0">Max burst</label>
          <input id="genBurst" type="number" value="50" style="width:90px" />
          <label style="margin:0">Seed</label>
          <input id="genSeed" placeholder="numero opzionale" style="width:120px" />
          <button id="importBtn" class="btn">Importa nella tabella</button>
        </div>

        <div style="margin-top:12px" class="table-wrap">
          <table id="procTable" aria-label="Process table">
            <thead>
              <tr>
                <th style="width:34px"><input id="selectAll" type="checkbox" /></th>
                <th style="width:60px">PID</th>
                <th style="width:80px">Arrival</th>
                <th style="width:80px">Burst</th>
                <th style="width:80px">Priority</th>
                <th>Note</th>
                <th style="width:110px">Azioni</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <button id="exportJSON" class="btn">Esporta JSON</button>
          <button id="clearTable" class="icon-btn">Svuota tabella</button>
          <div style="flex:1"></div>
          <label style="margin:0">Algoritmo</label>
          <select id="algorithm">
            <option value="fcfs">FCFS</option>
            <option value="sjf_non">SJF Non-preemptive</option>
            <option value="sjf_pre">SJF Preemptive</option>
            <option value="priority_non">Priority Non-preemptive</option>
            <option value="priority_pre">Priority Preemptive</option>
            <option value="rr">Round Robin</option>
          </select>
          <input id="quantum" type="number" min="1" value="4" style="width:80px" />
          <button id="runSim" class="btn">Esegui</button>
        </div>

        <div class="metrics" style="margin-top:12px">
          <div class="metric"><strong>Turnaround medio</strong><div id="avgTAT">—</div></div>
          <div class="metric"><strong>Waiting medio</strong><div id="avgWT">—</div></div>
          <div class="metric"><strong>Processi</strong><div id="count">0</div></div>
        </div>

        <div style="margin-top:10px">
          <label>Output JSON esportato</label>
          <textarea id="jsonOutput" style="width:100%;height:120px"></textarea>
        </div>
      </div>

      <div class="card">
        <h3>Anteprima e timeline</h3>
        <div class="small">Prime 50 righe della tabella e timeline compatta della simulazione.</div>
        <div style="margin-top:8px">
          <pre id="preview" style="max-height:300px;overflow:auto">Nessuna esecuzione</pre>
        </div>
        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0">
        <h3>Guida rapida</h3>
        <ul class="small">
          <li>Modifica ogni cella cliccandoci sopra. Valori non numerici vengono evidenziati.</li>
          <li>PID duplicati vengono tollerati ma è consigliato mantenerli univoci.</li>
          <li>Importa JSON nell'input, poi premi Importa per popolare la tabella.</li>
          <li>Premi Esporta JSON per copiare l'array dei processi nel box di output.</li>
        </ul>
      </div>
    </div>

    <footer>Turnaround = Completion − Arrival. Waiting = Turnaround − Burst.</footer>
  </div>

  <script>
  // ---------- utilities ----------
  function $(s, root=document) { return root.querySelector(s); }
  function $all(s, root=document) { return Array.from(root.querySelectorAll(s)); }

  // seeded RNG
  function makeRNG(seed) {
    let s = Number.isFinite(+seed) ? (seed >>> 0) : Math.floor(Math.random()*1e9);
    return function() { s = (s * 1664525 + 1013904223) >>> 0; return s/4294967296; };
  }

  // table management
  const tbody = $('#procTable tbody');
  function createRow(proc={pid:'', arrival:0, burst:1, priority:1, note:''}) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" class="rowSel" /></td>
      <td><input class="cell pid" value="${proc.pid}" /></td>
      <td><input class="cell arrival" value="${proc.arrival}" /></td>
      <td><input class="cell burst" value="${proc.burst}" /></td>
      <td><input class="cell priority" value="${proc.priority}" /></td>
      <td><input class="cell note" value="${proc.note ?? ''}" /></td>
      <td class="row-actions">
        <button class="icon-btn rowDup" title="duplica">Dup</button>
        <button class="icon-btn rowDel" title="elimina">Del</button>
      </td>
    `;
    // validation on input
    tr.querySelectorAll('input.cell').forEach(inp=>{
      inp.addEventListener('input', ()=> validateCell(inp));
      inp.addEventListener('keydown', (e)=> { if (e.key==='Enter') inp.blur(); });
    });
    tr.querySelector('.rowDel').addEventListener('click', ()=> { tr.remove(); updateCount(); });
    tr.querySelector('.rowDup').addEventListener('click', ()=> {
      const copy = rowToObj(tr);
      const newTr = createRow(copy);
      tbody.insertBefore(newTr, tr.nextSibling);
      updateCount();
    });
    tbody.appendChild(tr);
    return tr;
  }

  function validateCell(inp) {
    const cls = inp.classList;
    if (cls.contains('arrival') || cls.contains('burst') || cls.contains('priority') || cls.contains('pid')) {
      const v = inp.value.trim();
      const num = Number(v);
      const ok = v !== '' && Number.isFinite(num) && num >= 0;
      inp.classList.toggle('invalid', !ok);
    } else {
      inp.classList.remove('invalid');
    }
  }

  function rowToObj(tr) {
    const get = sel => (tr.querySelector(sel)?.value ?? '').trim();
    return {
      pid: Number(get('.pid')) || get('.pid') || '',
      arrival: Number(get('.arrival')) || 0,
      burst: Number(get('.burst')) || 0,
      priority: Number(get('.priority')) || 0,
      note: get('.note')
    };
  }

  function tableToArray(limit=Infinity) {
    const arr = [];
    for (const tr of tbody.children) {
      const obj = rowToObj(tr);
      arr.push({ pid: obj.pid, arrival: obj.arrival, burst: obj.burst, priority: obj.priority });
      if (arr.length >= limit) break;
    }
    return arr;
  }

  function clearTable() { tbody.innerHTML=''; updateCount(); }

  function updateCount() { $('#count').textContent = tbody.children.length; }

  // populate example or generated tasks
  $('#addRow').addEventListener('click', ()=> { createRow({pid:'',arrival:0,burst:1,priority:1}); updateCount(); });
  $('#clearTable').addEventListener('click', ()=> { clearTable(); $('#jsonOutput').value=''; $('#preview').textContent='Tabella svuotata'; });

  $('#genFill').addEventListener('click', ()=> {
    const n = Math.max(1, Number($('#genN').value)||1);
    const maxBurst = Math.max(1, Number($('#genBurst').value)||50);
    const seed = $('#genSeed').value;
    const rng = makeRNG(seed || Math.floor(Math.random()*1e9));
    clearTable();
    let t=0;
    for (let i=0;i<n;i++){
      t += Math.floor(rng()*3);
      createRow({pid:i+1, arrival:t, burst: Math.floor(rng()*maxBurst)+1, priority: Math.floor(rng()*10)+1});
      if (i >= 2000) { // safety cap for UI responsiveness
        const remain = n - (i+1);
        const summary = createRow({pid:'...', arrival:'...', burst:'...', priority:'...', note:`+${remain} rows omitted for UI`});
        break;
      }
    }
    updateCount();
  });

  // import JSON into input field or directly into table
  $('#importBtn').addEventListener('click', ()=> {
    const text = $('#jsonImport').value.trim();
    if (!text) { alert('Inserisci JSON nell\'input di import.'); return; }
    try {
      const arr = JSON.parse(text);
      if (!Array.isArray(arr)) throw new Error('JSON deve essere un array di oggetti.');
      clearTable();
      for (const p of arr) {
        createRow({
          pid: ('pid' in p) ? p.pid : '',
          arrival: Number(p.arrival ?? 0),
          burst: Number(p.burst ?? 0),
          priority: Number(p.priority ?? 0),
          note: p.note ?? ''
        });
      }
      updateCount();
      $('#preview').textContent = `Importati ${arr.length} righe.`;
    } catch (e) {
      alert('JSON non valido: ' + e.message);
    }
  });

  // quick import from json input field (single-line)
  $('#jsonImport').addEventListener('keydown', (e)=> { if (e.key === 'Enter' && (e.ctrlKey||e.metaKey)) { $('#importBtn').click(); } });

  // export table to JSON
  $('#exportJSON').addEventListener('click', ()=> {
    const arr = tableToArray(1000000);
    const json = JSON.stringify(arr, null, 2);
    $('#jsonOutput').value = json;
    $('#preview').textContent = json.split('\\n').slice(0,50).join('\\n');
  });

  // select all behavior
  $('#selectAll').addEventListener('change', (e)=> {
    $all('.rowSel').forEach(cb=> cb.checked = e.target.checked);
  });

  $('#delSelected').addEventListener('click', ()=> {
    $all('.rowSel').forEach(cb=> { if (cb.checked) cb.closest('tr').remove(); });
    updateCount();
  });

  // enable/disable quantum
  function toggleQuantum() { $('#quantum').disabled = $('#algorithm').value !== 'rr'; }
  $('#algorithm').addEventListener('change', toggleQuantum);
  toggleQuantum();

  // ---------- scheduling functions (copiate e adattate) ----------
  function computeMetrics(processes) {
    const n = processes.length;
    let totTAT=0, totWT=0;
    if (n === 0) return {avgTAT:0, avgWT:0, throughput:0};
    for (let p of processes) {
      const tat = p.completion - p.arrival;
      const wt = tat - p.burst;
      totTAT += tat;
      totWT += wt;
    }
    const makespan = Math.max(...processes.map(p=>p.completion)) - Math.min(...processes.map(p=>p.arrival));
    return { avgTAT: totTAT/n, avgWT: totWT/n, throughput: n / (makespan || 1) };
  }

  // Simulators optimized for arrays of objects
  function simulateFCFS(tasks) {
    const procs = tasks.map(t=>({...t, remaining: t.burst}));
    procs.sort((a,b)=> a.arrival - b.arrival || (a.pid - b.pid));
    let time = 0; const timeline=[];
    for (const p of procs) {
      if (time < p.arrival) time = p.arrival;
      p.start = time; time += p.burst; p.completion = time; p.remaining=0;
      timeline.push({pid:p.pid, from:p.start, to:p.completion});
    }
    return {procs,timeline};
  }

  function simulateSJFNon(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.burst<best){best=p.burst;idx=i;}}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const p=procs[idx]; p.start=time; time+=p.burst; p.completion=time; p.done=true; finished++; timeline.push({pid:p.pid,from:p.start,to:p.completion});
    }
    return {procs,timeline};
  }

  function simulateSJFPre(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.remaining<best){best=p.remaining;idx=i;}}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const cur=procs[idx]; const upcoming = procs.filter(p=>!p.done && p.arrival>time).map(p=>p.arrival);
      const nextArrival = upcoming.length? Math.min(...upcoming) : Infinity;
      const delta = Math.min(cur.remaining, nextArrival - time);
      if(delta===0){ time = nextArrival; continue; }
      const from=time,to=time+delta; if(!cur.hasOwnProperty('start')) cur.start=from;
      cur.remaining-=delta; timeline.push({pid:cur.pid,from,to}); time=to;
      if(cur.remaining===0){ cur.completion=time; cur.done=true; finished++; }
    }
    return {procs,timeline};
  }

  function simulatePriorityNon(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.priority<best){best=p.priority;idx=i;}
        else if(!p.done && p.arrival<=time && p.priority===best){ if(idx!==-1 && p.burst<procs[idx].burst) idx=i; }}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const p=procs[idx]; p.start=time; time+=p.burst; p.completion=time; p.done=true; finished++; timeline.push({pid:p.pid,from:p.start,to:p.completion});
    }
    return {procs,timeline};
  }

  function simulatePriorityPre(tasks) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    let time=0, finished=0; const timeline=[];
    while(finished<n){
      let idx=-1,best=Infinity;
      for(let i=0;i<n;i++){const p=procs[i]; if(!p.done && p.arrival<=time && p.priority<best){best=p.priority;idx=i;}}
      if(idx===-1){ time = Math.min(...procs.filter(p=>!p.done).map(p=>p.arrival)); continue; }
      const cur=procs[idx]; const upcoming = procs.filter(p=>!p.done && p.arrival>time).map(p=>p.arrival);
      const nextArrival = upcoming.length? Math.min(...upcoming) : Infinity;
      const delta = Math.min(cur.remaining, nextArrival - time);
      if(delta===0){ time = nextArrival; continue; }
      const from=time,to=time+delta; if(!cur.hasOwnProperty('start')) cur.start=from;
      cur.remaining-=delta; timeline.push({pid:cur.pid,from,to}); time=to;
      if(cur.remaining===0){ cur.completion=time; cur.done=true; finished++; }
    }
    return {procs,timeline};
  }

  function simulateRR(tasks, quantum) {
    const n = tasks.length; const procs = tasks.map(t=>({...t,remaining:t.burst,done:false}));
    procs.sort((a,b)=> a.arrival - b.arrival || (a.pid - b.pid));
    let time=0; const q=[]; let i=0; const timeline=[];
    while(true){
      while(i<n && procs[i].arrival<=time){ q.push(procs[i]); i++; }
      if(q.length===0){ if(i<n){ time = procs[i].arrival; continue; } else break; }
      const cur = q.shift();
      if(!cur.hasOwnProperty('start')) cur.start=time;
      const run = Math.min(cur.remaining, quantum);
      const from=time, to=time+run;
      cur.remaining-=run; timeline.push({pid:cur.pid,from,to}); time=to;
      while(i<n && procs[i].arrival<=time){ q.push(procs[i]); i++; }
      if(cur.remaining>0) q.push(cur); else { cur.completion=time; cur.done=true; }
      if(q.length===0 && i>=n) break;
    }
    return {procs,timeline};
  }

  // ---------- simulate runner ----------
  $('#runSim').addEventListener('click', ()=> {
    // validate table and build task array
    const rows = Array.from(tbody.children);
    const tasks = [];
    for (const tr of rows) {
      const obj = rowToObj(tr);
      // if any invalid, stop
      if (tr.querySelectorAll('.invalid').length) {
        alert('Ci sono valori non validi nella tabella. Correggi prima di eseguire.');
        return;
      }
      tasks.push({ pid: obj.pid, arrival: Number(obj.arrival), burst: Number(obj.burst), priority: Number(obj.priority) });
    }
    if (tasks.length === 0) { alert('La tabella è vuota. Aggiungi almeno un processo.'); return; }

    const alg = $('#algorithm').value;
    const q = Math.max(1, Number($('#quantum').value)||1);
    let result;
    const t0 = performance.now();
    if (alg === 'fcfs') result = simulateFCFS(tasks);
    else if (alg === 'sjf_non') result = simulateSJFNon(tasks);
    else if (alg === 'sjf_pre') result = simulateSJFPre(tasks);
    else if (alg === 'priority_non') result = simulatePriorityNon(tasks);
    else if (alg === 'priority_pre') result = simulatePriorityPre(tasks);
    else if (alg === 'rr') result = simulateRR(tasks, q);
    else { alert('Algoritmo non riconosciuto'); return; }
    const t1 = performance.now();

    const procs = result.procs.map(p=>({ pid:p.pid, arrival:p.arrival, burst:p.burst, completion:p.completion || (p.start+p.burst) }));
    const metrics = computeMetrics(procs);
    $('#avgTAT').textContent = metrics.avgTAT.toFixed(3);
    $('#avgWT').textContent = metrics.avgWT.toFixed(3);
    $('#count').textContent = procs.length;
    // preview first 50 processes
    $('#preview').textContent = procs.slice(0,50).map(p=>`PID ${p.pid} | arrival ${p.arrival} | burst ${p.burst} | completion ${p.completion}`).join('\\n');
    // compact timeline preview
    const merged = [];
    for (const seg of result.timeline || []) {
      const last = merged[merged.length-1];
      if (last && last.pid === seg.pid && Math.abs(last.to - seg.from) < 1e-9) last.to = seg.to; else merged.push({...seg});
    }
    const show = merged.slice(0,300).map(s=>`[${s.from.toFixed(2)}→${s.to.toFixed(2)}]P${s.pid}`).join(' ');
    const more = merged.length>300 ? ` ... (+${merged.length-300} seg)` : '';
    $('#jsonOutput').value = `Sim time: ${(t1-t0).toFixed(2)}ms\\n` + JSON.stringify(procs.slice(0,200), null, 2);
    $('#preview').textContent += '\\n\\nTimeline: ' + show + more;
  });

  // initialize with a few rows
  for (let i=0;i<6;i++) createRow({pid:i+1, arrival:i, burst: Math.floor(Math.random()*10)+1, priority: Math.floor(Math.random()*5)+1});
  updateCount();
  </script>
</body>
</html>

